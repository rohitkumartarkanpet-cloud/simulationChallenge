---
title: "Simulation Challenge: Coin-Flip Retirement Game"
author: "Rohit Kumar, Tarkanpet"
format:
  html:
    theme: flatly
    toc: true
    toc-location: right
    number-sections: true
    code-fold: true
    smooth-scroll: true
execute:
  echo: false
  warning: false
  message: false
jupyter: python3
---

# Overview

This project studies a coin-flip investment game played once per year from age 20 to age 75.

- Starting balance at age 20: **$30,000**  
- Each year: flip a fair coin  
  - Heads → multiply by **1.5** (50% gain)  
  - Tails → multiply by **0.6** (40% loss)

I compare two ways to play:

1. **100% strategy** – the entire balance is at risk every year.  
2. **25% strategy** – only 25% of the balance is exposed each year; the rest sits out that year.

The guiding questions:

- How wild can one lifetime path become from age 20 to 75?  
- Across many simulated lifetimes, what does the distribution of final balances look like?  
- How often do we retire with more than the original $30,000?  
- How does the 25% strategy change both risk and upside?

```{python}
#| label: setup
#| include: false

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

plt.style.use("dark_background")

age_start = 20
age_end = 75
n_years = age_end - age_start           # number of flips
initial_balance = 30_000
target_balance = initial_balance        # break-even target

p_head = 0.5
up = 0.50
down = -0.40

growth_head_full = 1 + up               # 1.5
growth_tail_full = 1 + down             # 0.6

fraction = 0.25
growth_head_frac = 0.75 + 1.5 * fraction   # 1.125
growth_tail_frac = 0.75 + 0.6 * fraction   # 0.90

def simulate_path_full(rng, n_years, initial_balance):
    balance = initial_balance
    balances = [balance]
    for _ in range(n_years):
        if rng.random() < p_head:
            balance *= growth_head_full
        else:
            balance *= growth_tail_full
        balances.append(balance)
    return np.array(balances)

def simulate_final_full(rng, n_years, initial_balance):
    balance = initial_balance
    for _ in range(n_years):
        if rng.random() < p_head:
            balance *= growth_head_full
        else:
            balance *= growth_tail_full
    return balance

def simulate_final_frac(rng, n_years, initial_balance):
    balance = initial_balance
    for _ in range(n_years):
        if rng.random() < p_head:
            balance *= growth_head_frac
        else:
            balance *= growth_tail_frac
    return balance

def summarize_array(x):
    x = np.asarray(x)
    return dict(
        count = x.size,
        mean = x.mean(),
        median = np.median(x),
        std = x.std(ddof=1),
        minimum = x.min(),
        maximum = x.max(),
    )
```

## Expected value after one flip

Imagine the very first year at age 20, right after we invest the $30,000.

Outcomes after that first coin flip:

- Heads: the account jumps to $45,000 (probability 0.5)  
- Tails: the account drops to $18,000 (probability 0.5)

The expected value after one flip is

\[
\mathbb{E}[W_1]
= 0.5 \times 45{,}000 + 0.5 \times 18{,}000
= 31{,}500.
\]

Gain in expected value: **$1,500**  
Gain as a percentage of the buy-in: **5%**

So, based on a single step, the game promises about a **5% boost** to wealth. The tension in this project is that we keep playing this game **55 years in a row**, and compounding can amplify both good and bad stretches.

::: callout-tip
#### Math lens

Let \(W_0\) be the starting wealth. One flip gives  

\[
W_1 = 
\begin{cases}
1.5 W_0 & \text{with prob. } 0.5, \\[4pt]
0.6 W_0 & \text{with prob. } 0.5.
\end{cases}
\]

Then  

\[
\mathbb{E}[W_1] = (0.5\cdot1.5 + 0.5\cdot0.6) W_0 = 1.05 W_0,
\]

so the expected gain per flip is 5% of current wealth.
:::

## One simulated path from age 20 to 75 (100% strategy)

To get a feel for the risk, I start with one sample lifetime where the entire account is exposed every single year.

```{python}
#| label: single-path
#| fig-cap: "One simulated path from age 20 to age 75 when 100% of the account is at risk each year."
#| fig-width: 8
#| fig-height: 4.5
#| out-width: "100%"

rng_single = np.random.default_rng(2025)
balances_single = simulate_path_full(rng_single, n_years, initial_balance)
ages = np.arange(age_start, age_end + 1)

fig, ax = plt.subplots(figsize=(8, 4.5))
ax.plot(
    ages,
    balances_single,
    marker="o",
    linewidth=2.2,
    color="#f06292",
    label="Account balance"
)
ax.fill_between(
    ages,
    balances_single,
    color="#f06292",
    alpha=0.20,
    linewidth=0
)
ax.axhline(
    initial_balance,
    linestyle="--",
    linewidth=1.5,
    color="#ffca28",
    label="Starting $30,000"
)
ax.set_xlabel("Age")
ax.set_ylabel("Account balance ($)")
ax.set_title("Single Lifetime: 100% Strategy")
ax.grid(alpha=0.35)
ax.legend()
fig.tight_layout()

final_single = balances_single[-1]
```

```{python}
#| label: single-path-text

print(f"Final balance at age {age_end}: ${final_single:,.2f}")
```

**Story of this path.**  
The account spends decades drifting up and down, often sitting below the original $30,000 line. By age 75 this run ends far from a “rich retirement”. A single unlucky cluster of tails late in life can erase years of earlier wins, which is exactly what makes the 100% strategy so fragile.

## 100 simulations – distribution for the 100% strategy

One path is a story; 100 paths form a distribution. Here I simulate **100 lifetimes** from age 20 to 75 where the full balance is at risk each year and record the final balance at age 75.

```{python}
#| label: sims-full
#| include: false

rng_full = np.random.default_rng(310)
n_runs = 100

finals_full = np.array([simulate_final_full(rng_full, n_years, initial_balance)
                        for _ in range(n_runs)])

stats_full = summarize_array(finals_full)
p_above_full = (finals_full >= target_balance).mean()

log_full = np.log(finals_full)
mu_full = log_full.mean()
sigma_full = log_full.std(ddof=0)
```

```{python}
#| label: hist-full
#| fig-cap: "Distribution of final balances for the 100% strategy (100 runs, log scale)."
#| fig-width: 8
#| fig-height: 4.8
#| out-width: "100%"

fig, ax = plt.subplots(figsize=(8, 4.8))

min_bal = max(finals_full.min(), 1e-2)
max_bal = finals_full.max()
bins = np.logspace(np.log10(min_bal*0.8), np.log10(max_bal*1.2), 24)

counts, bin_edges, patches = ax.hist(
    finals_full,
    bins=bins,
    edgecolor="white",
    alpha=0.95,
)

for i, patch in enumerate(patches):
    center = np.sqrt(bin_edges[i] * bin_edges[i+1])
    if center < target_balance:
        patch.set_facecolor("#ff6b6b")
        patch.set_hatch("///")
    else:
        patch.set_facecolor("#26c6da")
        patch.set_hatch("..")

x_curve = np.logspace(np.log10(min_bal*0.8), np.log10(max_bal*1.4), 800)
log_pdf = (1.0 / (x_curve * sigma_full * np.sqrt(2*np.pi))) *           np.exp(-0.5 * ((np.log(x_curve) - mu_full) / sigma_full)**2)
scale = counts.max() / log_pdf.max() if log_pdf.max() > 0 else 1.0
ax.plot(x_curve, log_pdf * scale, color="#ffffff", lw=2.2, label="Log-normal guide")

ax.axvline(target_balance, color="#40c4ff", linestyle="--", lw=2, label="Buy-in $30k")
ax.axvline(stats_full["median"], color="#ffeb3b", linestyle="--", lw=2, label="Median")
ax.axvline(stats_full["mean"], color="#b39ddb", linestyle="--", lw=2, label="Mean")

ax.set_xscale("log")
ax.set_xlim(bins[0], bins[-1])
ax.set_xlabel("Final balance ($, log scale)")
ax.set_ylabel("Number of simulations")
ax.set_title("Final Balances – 100% Strategy (100 Lifetimes)")
ax.grid(True, which="both", linestyle="--", alpha=0.35)

badge = (
    f"P(final ≥ $30k) = {p_above_full:.3f}\n"
    f"Mean = ${stats_full['mean']:,.0f}\n"
    f"Median = ${stats_full['median']:,.0f}"
)
ax.text(
    0.98,
    0.98,
    badge,
    transform=ax.transAxes,
    ha="right",
    va="top",
    fontsize=9,
    bbox=dict(boxstyle="round,pad=0.4",
              facecolor="#263238",
              alpha=0.9,
              edgecolor="#90caf9"),
)

ax.legend(loc="upper left", framealpha=0.85)
fig.tight_layout()
```

### Summary tables for the 100% strategy

```{python}
#| label: full-tables
#| tbl-cap: "Distribution statistics for the 100% strategy (100 simulated lifetimes)."

summary_full_df = pd.DataFrame({
    "Statistic": [
        "Count",
        "Mean final balance",
        "Median final balance",
        "Minimum",
        "Maximum",
        "Standard deviation",
        "P(final ≥ $30,000)"
    ],
    "Value": [
        f"{stats_full['count']}",
        f"${stats_full['mean']:,.2f}",
        f"${stats_full['median']:,.2f}",
        f"${stats_full['minimum']:,.2f}",
        f"${stats_full['maximum']:,.2f}",
        f"${stats_full['std']:,.2f}",
        f"{p_above_full:0.3f} ({p_above_full*100:0.1f}%)"
    ]
})

levels = [10, 25, 50, 75, 90]
percentiles_full = np.percentile(finals_full, levels)

percentile_full_df = pd.DataFrame({
    "Percentile": [f"{p}th" for p in levels],
    "Final balance ($)": [f"${v:,.2f}" for v in percentiles_full]
})

styled_summary = (
    summary_full_df
    .style
    .hide(axis="index")
    .set_table_styles([
        {"selector": "th",
         "props": [("background-color", "#1976d2"),
                   ("color", "white"),
                   ("font-weight", "bold"),
                   ("padding", "6px")]},
        {"selector": "tbody td",
         "props": [("padding", "6px")]},
    ])
)

styled_percentiles = (
    percentile_full_df
    .style
    .hide(axis="index")
    .set_table_styles([
        {"selector": "th",
         "props": [("background-color", "#2e7d32"),
                   ("color", "white"),
                   ("font-weight", "bold"),
                   ("padding", "6px")]},
        {"selector": "tbody td",
         "props": [("padding", "6px")]},
        {"selector": "tbody tr:nth-child(even)",
         "props": [("background-color", "#f5f5f5")]},
    ])
)

styled_summary, styled_percentiles
```

**Reading the picture.**  
The histogram is very skewed: most lifetimes end in the red, with a small cluster of enormous wins dragging the mean to the right. The median, lower percentiles, and the probability in the table make it clear that a “typical” player does not retire happy with this approach.

## Probability that the balance exceeds $30,000 at age 75

Here I zoom in on one question: *starting at age 20, what fraction of lifetimes end at or above $30,000 by age 75 when we always bet 100%?*

```{python}
#| label: prob-table
#| tbl-cap: "Probability that the final balance is at or above $30,000 under the 100% strategy."

n_success = int((finals_full >= target_balance).sum())

prob_df = pd.DataFrame({
    "Metric": [
        "Number of simulated lifetimes",
        "Years per lifetime (coin flips)",
        "Lifetimes with final balance ≥ $30,000",
        "Probability (decimal)",
        "Probability (percentage)",
        "Probability (final balance < $30,000)"
    ],
    "Value": [
        f"{n_runs}",
        f"{n_years}",
        f"{n_success}",
        f"{p_above_full:0.3f}",
        f"{p_above_full*100:0.1f}%",
        f"{1 - p_above_full:0.3f} ({(1 - p_above_full)*100:0.1f}%)"
    ]
})

styled_prob = (
    prob_df
    .style
    .hide(axis="index")
    .set_table_styles([
        {"selector": "th",
         "props": [("background-color", "#c62828"),
                   ("color", "white"),
                   ("font-weight", "bold"),
                   ("padding", "6px")]},
        {"selector": "tbody td",
         "props": [("padding", "6px")]},
        {"selector": "tbody tr:nth-child(even)",
         "props": [("background-color", "#ffebee")]},
    ])
)

styled_prob
```

In words: only a minority of lifetimes end above the starting $30,000, even though each single flip has positive expected value.

## Modified strategy – bet 25% of the balance each year

Now I test a more cautious rule: each year only **25%** of the account is exposed to the flip, and 75% sits on the sidelines for that year.

```{python}
#| label: sims-frac
#| include: false

rng_frac = np.random.default_rng(456)
finals_frac = np.array([simulate_final_frac(rng_frac, n_years, initial_balance)
                        for _ in range(n_runs)])

stats_frac = summarize_array(finals_frac)
p_above_frac = (finals_frac >= target_balance).mean()

log_frac = np.log(finals_frac)
mu_frac = log_frac.mean()
sigma_frac = log_frac.std(ddof=0)
```

### Overlay of the two strategies

```{python}
#| label: overlay-hist
#| fig-cap: "Final balances under the 100% and 25% strategies (log scale, 100 runs each)."
#| fig-width: 8
#| fig-height: 4.8
#| out-width: "100%"

fig, ax = plt.subplots(figsize=(8, 4.8))

min_all = min(finals_full.min(), finals_frac.min())
max_all = max(finals_full.max(), finals_frac.max())
bins_overlay = np.logspace(np.log10(min_all*0.8), np.log10(max_all*1.2), 24)

ax.hist(
    finals_full,
    bins=bins_overlay,
    alpha=0.55,
    color="#ff8a80",
    edgecolor="white",
    label="100% each year",
)
ax.hist(
    finals_frac,
    bins=bins_overlay,
    alpha=0.65,
    color="#80cbc4",
    edgecolor="white",
    label="25% each year",
)

ax.axvline(target_balance, color="#40c4ff", linestyle="--", lw=2, label="Buy-in $30k")

x_overlay = np.logspace(np.log10(min_all*0.8), np.log10(max_all*1.4), 800)

log_pdf_full = (1.0 / (x_overlay * sigma_full * np.sqrt(2*np.pi))) *                np.exp(-0.5 * ((np.log(x_overlay) - mu_full) / sigma_full)**2)
log_pdf_frac = (1.0 / (x_overlay * sigma_frac * np.sqrt(2*np.pi))) *                np.exp(-0.5 * ((np.log(x_overlay) - mu_frac) / sigma_frac)**2)

scale_full = ax.get_ylim()[1] / max(log_pdf_full.max(), 1e-6)
scale_frac = ax.get_ylim()[1] / max(log_pdf_frac.max(), 1e-6)

ax.plot(x_overlay, log_pdf_full * scale_full, color="#ff5252", lw=1.8, label="Log-normal (100%)")
ax.plot(x_overlay, log_pdf_frac * scale_frac, color="#26a69a", lw=1.8, label="Log-normal (25%)")

ax.set_xscale("log")
ax.set_xlabel("Final balance ($, log scale)")
ax.set_ylabel("Number of simulations")
ax.set_title("Distribution of Final Balances: Full-Stake vs 25%-Stake")
ax.grid(True, which="both", linestyle="--", alpha=0.35)
ax.legend(loc="upper left", framealpha=0.85)
fig.tight_layout()
```

### Side-by-side strategy comparison

```{python}
#| label: compare-tables
#| tbl-cap: "Comparison of the 100% and 25% strategies over 100 simulated lifetimes."

compare_df = pd.DataFrame({
    "Statistic": [
        "P(final ≥ $30,000)",
        "Mean final balance",
        "Median final balance",
        "Standard deviation",
        "Minimum",
        "Maximum"
    ],
    "100% each year": [
        f"{p_above_full:0.3f} ({p_above_full*100:0.1f}%)",
        f"${stats_full['mean']:,.2f}",
        f"${stats_full['median']:,.2f}",
        f"${stats_full['std']:,.2f}",
        f"${stats_full['minimum']:,.2f}",
        f"${stats_full['maximum']:,.2f}",
    ],
    "25% each year": [
        f"{p_above_frac:0.3f} ({p_above_frac*100:0.1f}%)",
        f"${stats_frac['mean']:,.2f}",
        f"${stats_frac['median']:,.2f}",
        f"${stats_frac['std']:,.2f}",
        f"${stats_frac['minimum']:,.2f}",
        f"${stats_frac['maximum']:,.2f}",
    ]
})

styled_compare = (
    compare_df
    .style
    .hide(axis="index")
    .set_table_styles([
        {"selector": "th",
         "props": [("background-color", "#455a64"),
                   ("color", "white"),
                   ("font-weight", "bold"),
                   ("padding", "6px")]},
        {"selector": "tbody td",
         "props": [("padding", "6px")]},
        {"selector": "tbody tr:nth-child(even)",
         "props": [("background-color", "#eceff1")]},
    ])
)

styled_compare
```

## Kelly-style reflection

::: callout-tip
#### Kelly perspective

The Kelly Criterion gives the stake fraction that maximizes long-run (geometric) growth for a repeated bet.  

For this coin-flip game (50% chance of +50%, 50% chance of −40%), the Kelly calculation produces an optimal stake fraction close to **25%** of the account each round.
:::

Viewed through that lens:

- The **100% strategy** is far above Kelly. It offers a few impressive retirements and many that end below the original $30,000 after 55 years of flips.  
- The **25% strategy** sits near the Kelly fraction. It improves the odds of finishing ahead, raises the median outcome, and cuts back the most painful losses.

For a long investing life from **age 20 to 75**, the fractional strategy looks like a more realistic way to enjoy the game without letting a long tail of bad luck wreck the outcome.
